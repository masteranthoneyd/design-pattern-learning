## 单例模式

单例模式虽然简单, 但实现方法却有辣么多, 但都有其优缺点, 比如:

* 饿汉式在类加载的时候就初始化了单例, 牺牲了前期的一些**内存**.
* 懒汉式虽然实现了延迟加载, 但通过加锁的方式牺牲了部分**性能**.
* 而这里面又存在一些陷阱:
  * 简单的单例模式(不加锁)在**多线程**的场景下可能导致出现多个实例.
  * 双重检测在不加 `volatile` 关键字情况下, 可能出现不可预测的情况:
      * `instance = new Singleton()` 并不是一个原子性的操作, 因为**指令重排**的原因, 实例的声明周期可能变成了: 分配空间 -> 赋值内存地址给引用 -> 初始化. 这样其他线程拿到了不为空的实例, 但实际上实例还没完成初始化.
      * 由于**内存可见性**, 可能导致实例在A线程创建后未更新到主内存, B线程判断实例为空, 又创建了一个.
  * 需要序列化的时候要实现 `readResolve` 方法, 不然反序列化出来的是一个新的实例(枚举除外).
  * 除了枚举之外的单例, 都可以通过**反射机制**进行**破坏**. 枚举天然不能通过反射调用构造器, 因为枚举没有无参构造器, 只有一个 `[class java.lang.String, int]` 的构造器, 而且就算拿到了构造器, 也会调用失败, 在 `class.newInstance` 中就已经定义了.
    * 题外话, 通过一些手段, 可以将反射构造实例的成本提高, 比如将类定义为**抽象类**, 通过在工厂实现匿名内部类. 但是通过一些非常规手段还是可以做到, 毕竟**字节码是开放的**, 通过 ASM 可以随意修改. 而且, 单例模式本身的用意只是在被调用者调用的时候, 返回的是同一个实例, 防止反射调用那已经到安全层面了, 日常的业务没必要考虑到那么深, 如果一定要, 那么直接使用**枚举**吧~
    

**其他缺点**:
* 控制了自己的生命周期, 显得不太符合 SRP
* 代码耦合度高, 不利于测试
* 几乎很难集成

** JDK 中的应用**:
* `java.lang.Runtime.getRuntime`
* `java.lang.System.getSecurityManager`

